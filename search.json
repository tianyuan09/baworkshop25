[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Business Analytics Workshop",
    "section": "",
    "text": "Welcome\nWelcome to the Business Analytics Workshop 2025!\nBuilding on prior exposure to programming and modeling fundamentals, this workshop focuses on real-world applications through cutting-edge tools like VS Code, Git, GitHub Copilot, and no-code/low-code AI agent platforms. Participants will engage with case-based exercises and live demonstrations to explore how modern data-driven teams collaborate, code, and build AI-enhanced solutions in agile business environments. This workshop seeks to bridge analytical modeling, modern software practices, and AI development workflows.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "bash.html",
    "href": "bash.html",
    "title": "1Â  Command Lines and Terminal",
    "section": "",
    "text": "1.1 The Missing Piece\nMany students begin your programming journey by writing Python directly in platforms like Google Colab - no setup, no files, no terminals. These Jupyter notebook environments make coding easy; however, this convenience often means skipping an important part of programming: working with real Python files (.py) and using the terminal to run and manage code.\nThis â€œmissing pieceâ€ is essential for understanding how programming works in real projects, servers, and production systems.\nSo, before diving deeper into advanced business data workflows, weâ€™ll start by filling this gap, and learn the command lines and terminal to navigate files, run Python scripts, and operate in professional computing environments.\nWhat Youâ€™ll Learn Next",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#the-missing-piece",
    "href": "bash.html#the-missing-piece",
    "title": "1Â  Command Lines and Terminal",
    "section": "",
    "text": "Warningâš ï¸ Importance of Command Line and Terminal\n\n\n\nIf you skip learning command line skills or avoid the terminal, youâ€™ll struggle to work on real-world projects, collaborate effectively with teams, or operate in servers or cloud platforms â€” where graphical interfaces arenâ€™t available. The terminal isnâ€™t just a tool for experts; itâ€™s the foundation for professional workflows in data science and engineering.\n\n\n\n\n\nMain operating systems: Windows, macOS, Linux/Unix\nGUI vs terminal and why terminals matter\nBash shell basics for programming and data science",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#operating-systems-overview",
    "href": "bash.html#operating-systems-overview",
    "title": "1Â  Command Lines and Terminal",
    "section": "1.2 Operating Systems Overview",
    "text": "1.2 Operating Systems Overview\nMost students in this course use Windows, which dominates personal computers with roughly 70â€“75% of the global desktop market. macOS holds about 15â€“20%, while Linux and others make up a small share of personal use.\nIn contrast, the enterprise, cloud, AI/ML, and high-performance computing (HPC) worlds are very different. Linux and other Unix-like systems are the backbone in web servers, cloud computing and supercomputers, making up nearly half of cloud workloads and being the OS for all top 500 supercomputers. Popular Unix and Linux systems include:\n\nUbuntu\nDebian\nFedora\nRed Hat Enterprise Linux (RHEL)\n\n\n\n\n\n\n\nNotemacOS is Unix-based\n\n\n\nAlthough macOS looks different, it is actually Unix-based, meaning the terminal commands and Bash shell youâ€™ll learn in this course work much the same on both macOS and Linux.\n\n\n\nServers Linux holds a 62.7% market share for server operating systems.\n\nWeb servers: 77â€“88% of public web servers run on Linux or other Unix-like systems. It is the most used operating system for web servers globally.\n\nCloud computing Cloud workloads are heavily dependent on Linux-based operating systems. As of mid-2025, Linux powers 49.2% of all global cloud workloads.\nSupercomputers Linux has a complete monopoly in the supercomputing sector. 100% market share: Since 2017, 100% of the worldâ€™s top 500 supercomputers have run on Linux.\nAI and ML workloads Linux is the clear leader for AI and ML projects and infrastructure. In mid-2025, 87.8% of machine learning workloads ran on Linux infrastructure. Large ML and data science deployments predominantly run on Linux-based or Unix-based servers.\n\nCloud environments: Cloud providers like AWS, Google Cloud (GCP), Colab, and Microsoft Azure, which are leading providers for AI services, primarily offer Linux-based instances for running AI and ML tasks.\n\n\nSource: Wikipedia - Usage share of operating systems Azure Official Page, Microsoft Tech Community Update (Feb 2025)\n\n1.2.1 What Operating System does Google Colab use?\nLetâ€™s take a look at what is the operating system (OS) that running Google Colab. You can type the following command lines in the Terminal.\n# Bash\n# Display info about the operating system\ncat /etc/*-release\n\n# Display the Linux kernel version and build info\ncat /proc/version\nSee image below for the outputs.",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#what-is-a-terminal",
    "href": "bash.html#what-is-a-terminal",
    "title": "1Â  Command Lines and Terminal",
    "section": "1.3 What Is a Terminal?",
    "text": "1.3 What Is a Terminal?\n\nA terminal (also called a command line or shell) is a text-based interface that lets you interact directly with your computer by typing commands.\nBefore graphical interfaces (with windows, icons, and a mouse) were invented, the terminal was the primary way users operated computers â€” to run programs, manage files, and control hardware.\nEVERY operating system includes a terminal app:\n\nWindows:\n\nCommand Prompt(cmd)\nPowerShell\nor Bash (through Windows Subsystem for Linux)\nLinux: Bash is the default shell on most Linux systems (see Colab terminal)\n\nmacOS: Zsh in Terminal app (based on Unix) is the default terminal in MacOS, see image below.\n\n\n\n\n\n\n\nNoteBash vs Zsh\n\n\n\n\nBoth Bash and Zsh are terminals that interpret your commands, and they work almost the same.\n\n\n\n\nThe terminal can do almost everything you normally do with a mouse:\n\nNavigate files and folders\n\nRun programs or scripts\n\nInstall and manage software\n\nConnect to remote servers\n\nAutomate repetitive tasks with shell scripts\n\nData scientists and developers rely on the terminal for its speed and automation, especially when working in cloud environments like Google Colab, GitHub codescpaces, or on Linux servers.",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#why-learn-bash-commands-and-terminal",
    "href": "bash.html#why-learn-bash-commands-and-terminal",
    "title": "1Â  Command Lines and Terminal",
    "section": "1.4 Why Learn Bash commands and Terminal?",
    "text": "1.4 Why Learn Bash commands and Terminal?\nFirst, data science projects often run on servers or cloud environments, not personal laptops which lack the computational power for large-scale training, data processing, or deployment.\nThese servers â€” such as AWS EC2, Azure VMs, or Google Cloud Compute instances â€” usually run Linux or Unix systems and donâ€™t include a graphical user interface (GUI) by default. â€” they are managed entirely through the command line interface (CLI). To interact with them efficiently, you use Bash, a powerful and widely used command-line shell.\n\n\n\n\n\n\nTipWhat is a GUI?\n\n\n\nA Graphical User Interface (UI) is the visual part of your computer â€” windows, buttons, and menus you click with the mouse. However, Linux servers donâ€™t usually have this kind of visual interface.\nInstead, users interact with them through script commands typed into a terminal such as bash.\n\n\n\n1.4.1 GUI, CLI, Terminal and Desktop\n\n\nGUI (Graphical User Interface) â€“ The visual interface you use with a mouse, icons, and windows, such as Windows desktop, macOS Finder. GUIs are user-friendly but less efficient for automation or remote access.\nCLI (Command Line Interface) â€“ A text-based interface where you type commands instead of clicking.\nTerminal â€“ The program that provides access to the CLI. Itâ€™s like a window that lets you type commands and see text output, such as Windows PowerShell, macOS Terminal, Linux bash Terminal.\nDesktop Environment â€“ The collection of GUI components that make up the userâ€™s graphical workspace â€” including the taskbar, file explorer, and app windows; such as Windows Desktop, macOS.\n\n\n\n\n\n\n\nNoteSummary\n\n\n\n\nThe Terminal gives you access to the CLI, while the Desktop Environment provides a GUI.\n\nBoth let you control the same computer â€” one through text, the other through graphics.",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#learning-bash-commands-in-colab",
    "href": "bash.html#learning-bash-commands-in-colab",
    "title": "1Â  Command Lines and Terminal",
    "section": "1.5 Learning Bash commands in Colab",
    "text": "1.5 Learning Bash commands in Colab\nMastering Bash is essential. It enables you to write scripts, manage jobs, and execute commands directly on compute servers â€” a critical skill when working with large datasets or LLM pipelines.\nWe are going to learn basic bash commands to:\n\nNavigate and manage files\nRun Python (.py) scripts and other programs (e.g., pip) directly from the command line\nWork efficiently within server-based or local terminal environments\n\nWe will use Google Colab to learn bash commands in Linux system.\nPlease create or open a new Colab notebook, and then open the Terminal panel.\n\n1.5.1 File Directory in Google Colab\nWhen you launch a new Colab notebook, the environment starts with a temporary Linux file system that looks like this:\n/\nâ”œâ”€â”€ bin/\nâ”œâ”€â”€ boot/\nâ”œâ”€â”€ content/\nâ”‚   â”œâ”€â”€ drive/           â† your Google Drive (if mounted)\nâ”‚   â”œâ”€â”€ sample_data/     â† sample datasets provided by Colab\nâ”‚   â””â”€â”€ (your files)     â† any files you upload or create\nâ”œâ”€â”€ dev/\nâ”œâ”€â”€ etc/\nâ”œâ”€â”€ home/\nâ”‚   â””â”€â”€ root/\nâ”œâ”€â”€ lib/\nâ”œâ”€â”€ media/\nâ”œâ”€â”€ mnt/\nâ”œâ”€â”€ opt/\nâ”œâ”€â”€ proc/\nâ”œâ”€â”€ root/                â† default home directory if you type `cd ~`\nâ”œâ”€â”€ run/\nâ”œâ”€â”€ sbin/\nâ”œâ”€â”€ srv/\nâ”œâ”€â”€ sys/\nâ”œâ”€â”€ tmp/\nâ””â”€â”€ usr/\n\n\n\n1.5.2 Lab: Linux and bash\n\nDisplay info about the operating system.\n\ncat /etc/*-release\n\nDisplay the Linux kernel version and build info.\n\ncat /proc/version\n\n\n1.5.3 Lab: Paths, Folders, Directories (pwd)\n\nPrint your current working directory (the folder you are â€œinâ€). A directory is a folder, directory and folder are the same thing.\n\npwd\n#/content\nPlease type pwd 5 times and each time say â€œprint working directoryâ€.\nWhen to use pwd? if you lost in folders and donâ€™t know where you are in the directories or folders, pwd will tell you where you are.\n/content# pwd\n#/content\n\n\n1.5.4 Lab: List Directory (ls)\nThe ls command is used to list files and folders in a directory.\nHere are some of the most commonly used ones with options (such as -a, -l)\n# List files and folders in the current directory\nls\n\n# List **all** files, including hidden ones (those starting with .)\nls -a\n\n# List files in a detailed (**long**) format â€” shows permissions, owner, size, and date\nls -l\n\n# Combine options: show all files in detailed view\nls -la\n\n# Sort files by modification **time** (newest first)\nls -lt\n\n\n1.5.5 Lab: Change Directory (cd)\n\ncd sample_data: go the sample_data folder under the current directory.\ncd ..: go the parent folder.\ncd ~: go to the home folder. In Colab, the home folder is \\root. If you are lost in a directory and want to start over from a safe directory â€“ your home. You can type cd ~, and you will be taken to the home directory.\n\n# go into the sample_data folder\nls\ncd sample_data\nls\n\n\n# Move up one folder (to the parent directory /content)\ncd ..\n\n# Go back to your \"home\" folder (/root in Colab)\ncd ~\npwd\n\n# To-do: find a way to go back to the /content folder. \n\n\n\n1.5.6 Lab: Make A Directory (mkdir)\n# Create a new folder named \"data\" under /content \nmkdir data\n\n# Make multiple folders at once\nmkdir project scripts results\n\n# Check that they were created\nls\n\n\n1.5.7 Lab: curl\nGo to the \"data\" directory, and download a file from the internet. in curl -O &lt;URL&gt;, -O stands for saving file with the same name as on the web server.\n# Go to the \"data\" Directory\n\ncd data\n\n# Download a small sample text file and save it with the same name. \ncurl -O https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv\n\n# List files to confirm itâ€™s there\nls\n\n\n1.5.8 Lab: Clear the Screen (clear)\n# Clear the terminal screen\nclear\n\n\n1.5.9 Lab: Remove Directory (rmdir)\n# Create an empty folder named \"temp_folder\"\nmkdir temp_folder\n\n# Remove the empty folder\nrmdir temp_folder\n\n# Create multiple empty folders and remove them\nmkdir folder1 folder2\nrmdir folder1 folder2\n\n\n1.5.10 Lab: Making Empty Files (touch)\n# Create an empty file named \"notes.txt\"\ntouch notes.txt\n\n# Create multiple files at once\ntouch a.txt b.txt c.txt\n\n# Verify files were created\nls\n\n\n1.5.11 Lab: Copy a File (cp)\n# Copy a file to a new file\ncp notes.txt notes_backup.txt\n\n# Create a folder to copy into\nmkdir backup\n\n# Copy a file into a different folder\ncp notes.txt backup/\n\n# Check the results\nls backup\n\n\n1.5.12 Lab: Moving/Rename a File (mv)\n# Move a file into a different folder\nmv notes_backup.txt backup/\n\n# Rename a file\nmv notes.txt todo.txt\n\n# Verify the changes\nls\n\n\n1.5.13 Lab: Stream a File (cat)\n# Display the contents of a file\ncat todo.txt\n\n# To-do: Display the README.md file in the \"sample_data\" folder:\n\n\n# Display a system file (try this!)\ncat /etc/*-release\n\n\n1.5.14 Lab: Removing a File (rm)\n# Create some temporary files first\ntouch old.txt temp.txt sample.txt\n\n# Remove a single file\nrm old.txt\n\n# Remove multiple files\nrm temp.txt sample.txt\n\n# Remove an entire folder and its contents (be careful!)\nrm -r backup\n\n\n1.5.15 Lab: Exiting Your Terminal (exit)\n# Exit the current terminal session\nexit",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#summary-table-common-bash-commands",
    "href": "bash.html#summary-table-common-bash-commands",
    "title": "1Â  Command Lines and Terminal",
    "section": "1.6 Summary Table â€“ Common Bash Commands",
    "text": "1.6 Summary Table â€“ Common Bash Commands\n\n\n\n\n\n\n\n\nCommand\nPurpose\nExample\n\n\n\n\npwd\nPrint working directory\npwd\n\n\nls\nList files and folders\nls -la\n\n\ncd\nChange directory\ncd /content\n\n\nmkdir\nMake a new directory\nmkdir data\n\n\nrmdir\nRemove an empty directory\nrmdir temp_folder\n\n\ncurl\nDownload a file from the internet\ncurl -O https://example.com/file.txt\n\n\ntouch\nCreate an empty file\ntouch notes.txt\n\n\ncp\nCopy a file\ncp notes.txt backup/\n\n\nmv\nMove or rename a file\nmv old.txt new.txt\n\n\ncat\nView contents of a file\ncat notes.txt\n\n\nrm\nRemove a file or folder\nrm -r foldername\n\n\nclear\nClear the screen\nclear\n\n\nexit\nExit the terminal\nexit",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#h2-dir-in-codespaces",
    "href": "bash.html#h2-dir-in-codespaces",
    "title": "1Â  Command Lines and Terminal",
    "section": "1.7 Directory Structure in GitHub Codespace Terminal",
    "text": "1.7 Directory Structure in GitHub Codespace Terminal\n/\nâ”œâ”€â”€ bin/\nâ”œâ”€â”€ boot/\nâ”œâ”€â”€ dev/\nâ”œâ”€â”€ etc/\nâ”œâ”€â”€ home/\nâ”‚   â””â”€â”€ codespace/          â† your user home directory if you do `cd ~`\nâ”œâ”€â”€ lib/\nâ”œâ”€â”€ lib64/\nâ”œâ”€â”€ media/\nâ”œâ”€â”€ mnt/\nâ”œâ”€â”€ opt/\nâ”œâ”€â”€ proc/\nâ”œâ”€â”€ root/\nâ”œâ”€â”€ run/\nâ”œâ”€â”€ sbin/\nâ”œâ”€â”€ srv/\nâ”œâ”€â”€ sys/\nâ”œâ”€â”€ tmp/\nâ”œâ”€â”€ usr/\nâ””â”€â”€ workspaces/\n    â””â”€â”€ /codespaces-jupyter     â† your GitHub repo (default working dir)\n\n\n1.7.1 Bash in VS codespaces\nRestart your github codespaces.\n\nMake sure your can see the Terminal panel. If you accidently closed your terminal, you can always start one (or many) following the steps below.\n\nYou also can start a second terminal via the Terminal panel.\n\n\n\n1.7.2 Lab: create the scripts folder\nUsing the bash terminal to create a scripts folder under GitHub default working dir /workspaces/codespaces-jupyter, and create an empty my_script.py file in the scripts folder.\n\n\n\n\n\n\nTipTip\n\n\n\nYou may find the commands pwd, mkdir, ls, cd, and touch helpful for completing this exercise.\n\n\nYour task is to:\n\nVerify your current working directory.\n\nCreate a new folder called scripts inside the project root.\n\nList the directory contents to confirm that scripts was created successfully.\n\nNavigate into the scripts folder.\n\nConfirm it is empty.\n\nCreate a new Python file named my_script.py inside the scripts folder.\n\nWrite the Bash commands needed to accomplish each step.\nOnce you complete the task, your explorer should look like below:\n\n\n\n\n\n\n\nCautionSolution\n\n\n\n\n\n@tianyuan09 âœ /workspaces/codespaces-jupyter (main) $ pwd\n/workspaces/codespaces-jupyter\n@tianyuan09 âœ /workspaces/codespaces-jupyter (main) $ mkdir scripts\n@tianyuan09 âœ /workspaces/codespaces-jupyter (main) $ ls\nLICENSE  README.md  data  notebooks  requirements.txt  scripts\n@tianyuan09 âœ /workspaces/codespaces-jupyter (main) $ cd scripts\n@tianyuan09 âœ /workspaces/codespaces-jupyter/scripts (main) $ ls\n@tianyuan09 âœ /workspaces/codespaces-jupyter/scripts (main) $ touch my_script.py",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "python-terminal.html",
    "href": "python-terminal.html",
    "title": "2Â  Run .py scripts with Bash",
    "section": "",
    "text": "2.1 Why Run Python Scripts from Terminal?\nWhile interactive environments like Jupyter notebooks are great for exploration and prototyping, running Python scripts (.py files) from the terminal is essential for:",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "python-terminal.html#why-run-python-scripts-from-terminal",
    "href": "python-terminal.html#why-run-python-scripts-from-terminal",
    "title": "2Â  Run .py scripts with Bash",
    "section": "",
    "text": "Production workflows: Automated data processing, model training, and deployment\nServer environments: Most servers donâ€™t have graphical interfaces\nBatch processing: Running scripts on large datasets or multiple files\nScheduling: Using cron jobs or task schedulers to run scripts automatically\nCommand-line arguments: Passing parameters to scripts dynamically\nPerformance: Scripts often run faster than notebooks for large tasks\n\n\n\n\n\n\n\nNoteFor Example\n\n\n\nData scientists often submit training jobs via Bash scripts like:\npython train_model.py --epochs 10\nIt runs the Python script train_model.py to train the model for 10 epochs.",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "python-terminal.html#ipynb-notebook-vs-.py-script-files",
    "href": "python-terminal.html#ipynb-notebook-vs-.py-script-files",
    "title": "2Â  Run .py scripts with Bash",
    "section": "2.2 .ipynb Notebook vs .py Script Files",
    "text": "2.2 .ipynb Notebook vs .py Script Files\nFigureÂ 2.1 illustrates the difference between running Python code in .ipynb notebook versus in `.pyâ€™ script file.\n\n\n\n\n\n\nFigureÂ 2.1: Comparison of Jupyter Notebook and Python Script formats\n\n\n\nUnderstanding the Terminal\nSee directory structure in codespaces in the previous chapter.\nIn the terminal, it always starts with:\n\n@tianyuan09 âœ /workspaces/codespaces-jupyter (main) $.\n\n@tianyuan09 âœ /workspaces/codespaces-jupyter (main) $\nâ”‚           â”‚                 â”‚                   â”‚\nâ”‚           â”‚                 â”‚                   â””â”€ Prompt symbol ($): \nâ”‚           â”‚                 â”‚                      shows the terminal is ready for input\nâ”‚           â”‚                 â”‚\nâ”‚           â”‚                 â””â”€ Current working directory:\nâ”‚           â”‚                    youâ€™re inside the folder â€œcodespaces-jupyterâ€\nâ”‚           â”‚                    located under â€œ/workspacesâ€\nâ”‚           â”‚\nâ”‚           â””â”€ Arrow (âœ): \nâ”‚               just a decorative separator in the prompt\nâ”‚\nâ””â”€ Username (and sometimes host): \n   â€œtianyuan09â€ â€” the current user logged into this environment\nDifference between .ipynb Notebook and .py Script File.\n\n\n\n\n\n\n\n\nFeature\n.ipynb (Jupyter Notebook)\n.py (Python Script)\n\n\n\n\nStructure\nStructured JSON format combining code, text cells in Markdown, and outputs.\nPlain text file containing only Python code and comments #.\n\n\nExecution\nRun one cell at a time, showing output immediately below each cell.\nExecuted all at once using a command like python my_script.py, seen â‘£ in FigureÂ 2.1.\n\n\nUse Case\nIdeal for data analysis, visualization, and teaching due to its interactive nature.\nBetter for automation, deployment of production-ready code.\n\n\n\n\n2.2.1 Lab: Create and run a .py script file\nFirst, letâ€™s create a hello.py under the scripts folder.\n# file path: scripts/hello.py\nprint(\"Hello from Python!\")\nprint(\"This script is running from the terminal.\")\n\n# Get current date and time\nimport datetime\nnow = datetime.datetime.now()\nprint(f\"Current time: {now}\")\nYou can directly use explorer or use bash command FigureÂ 2.2.\n\n\n\n\n\n\nFigureÂ 2.2: Create and run your 1st script file\n\n\n\nExpected output:\nHello from Python!\nThis script is running from the terminal.\nCurrent time: 2025-10-13 10:30:45.123456",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "python-terminal.html#other-python-related-commmands",
    "href": "python-terminal.html#other-python-related-commmands",
    "title": "2Â  Run .py scripts with Bash",
    "section": "2.3 Other Python-related Commmands",
    "text": "2.3 Other Python-related Commmands\n\n2.3.1 Checking Your Python Version\n# Check Python version\npython --version\npython3 --version\n\n# Check which Python executable you're using\nwhich python\nwhich python3\n\n\n2.3.2 Different Python Commands\nDepending on your system setup, you might need to use different commands:\n# On systems with Python 3 as default\npython hello.py\n\n# OR\npython3 hello.py\n\n# OR Using specific Python version\npython3.9 hello.py\npython3.12 hello.py\n\n\n2.3.3 Running pip command\n\n\n\n\n\n\nImportantTip\n\n\n\npip is a command-line tool, not Python code. You actually should run pip install ... in your terminal.\n\n\nAlthough you have run pip inside a code cell in Colab with !, such as !pip install pandas, the notebook actually sends it as a command line to the terminal to execute. It is equivalent to running pip install pandas in the terminal, see in FigureÂ 2.3.\n\n\n\n\n\n\nFigureÂ 2.3: pip in terminal\n\n\n\n\n\n\n\n\n\nImportantHow to install package for .py files?\n\n\n\nIn regular .py files (non-notebook files), pip commands must be executed in the terminal, not inside the script itself.\nFor example, to install the streamlit package, run this in your terminal:\npip install streamlit\n\n\n\nList all the packages installed:\n# Check installed packages\npip list\nPlease install streamlit in your codespaces.",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "python-terminal.html#working-with-command-line-arguments",
    "href": "python-terminal.html#working-with-command-line-arguments",
    "title": "2Â  Run .py scripts with Bash",
    "section": "2.4 Working with Command-Line Arguments",
    "text": "2.4 Working with Command-Line Arguments\n\n2.4.1 Creating a Script with Arguments\n.py files with arguments allow the users to provide input directly when running the script. Please work on the following example.\n# create and save in scripts/greet.py\nimport sys\nprint(sys.argv) # sys.argv is a list of string typed after python in the bash\n\n# Check if arguments were provided\nif len(sys.argv) &lt; 2:\n    print(\"Usage: python greet.py &lt;name&gt;\")\n    sys.exit(1)\n\nname = sys.argv[1]\nprint(f\"Hello, {name}!\")\n\n# Optional: Handle multiple arguments\nif len(sys.argv) &gt; 2:\n    age = sys.argv[2]\n    print(f\"You are {age} years old.\")\n\n\n2.4.2 Running with Arguments\n# Run with one argument\npython greet.py Alice\n\n# Run with multiple arguments\npython greet.py Bob 25\n\n# Without arguments (will show usage message)\npython greet.py\n\n\n2.4.2.1 sys.argv â€” what it really is\nsys.argv is a list of strings containing everything typed after python in the terminal.\nFor example, if you run:\npython greet.py Alice 25\nThen in Python:\nimport sys\nprint(sys.argv)\n# output: ['greet.py', 'Alice', '25'] # a list\n\n\n2.4.2.2 Index meaning\n\n\n\n\n\n\n\n\nIndex\nValue\nMeaning\n\n\n\n\nsys.argv[0]\n'greet.py'\nthe name of the script file being executed\n\n\nsys.argv[1]\n'Alice'\nthe first argument typed after the script name\n\n\nsys.argv[2]\n'25'\nthe second argument (if given)\n\n\n\n\n\n2.4.2.3 why name = sys.argv[1]?\nBecause:\n\nsys.argv[0] is always the script name (greet.py)\nsys.argv[1] is the first real argument that the user provides. In this case, the personâ€™s name.\n\nIf you used sys.argv[0], it would just say: Hello, greet.py!",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "python-terminal.html#running-scripts-in-different-directories.",
    "href": "python-terminal.html#running-scripts-in-different-directories.",
    "title": "2Â  Run .py scripts with Bash",
    "section": "2.5 Running Scripts in Different Directories.",
    "text": "2.5 Running Scripts in Different Directories.\n\n2.5.1 Absolute Paths\n# Run script from anywhere using absolute path\npython /Users/username/projects/my_script.py\n/Users/username/projects/my_script.py is a absolute file path.\nAbsolute paths:\n\nOn macOS/Linux, starts with /.\nOn Windows, starts with a drive letter like C:/.\nIn short, it always starts from the root of the filesystem (the top level).\n\nYou can find either the relative or aboslute file paths in codespaces:\n\n\n\n2.5.2 Relative Paths\n# Run script in current directory\npython ./script.py\n\n# Run script in subdirectory\npython scripts/data_analysis.py\n\n# Run script in parent directory\npython ../utilities/helper.py\nThe paths above (e.g.Â ../utilities/helper.py) are relative paths.\n\nThey donâ€™t start with / or a drive letter (e.g.Â C:/).\nThey may include . (current folder) or .. (parent folder).\nThey starts from your current working directory (pwd).\n\n\n\n2.5.3 Difference in absolute vs relative paths\n\n\n\nStarts With\nType\nMeaning\n\n\n\n\n/ (Linux/Mac)\nAbsolute\nStarts at root of file system\n\n\nC:\\ (Windows)\nAbsolute\nStarts at root of drive\n\n\n. or ..\nRelative\nBased on current working directory\n\n\nNo / or C:\\\nRelative\nImplied to start from current folder\n\n\n\n\n\n2.5.4 Changing Directories\n# Navigate to script directory, then run\ncd /path/to/scripts\npython analysis.py\n\n# Or combine in one line\ncd /path/to/scripts && python analysis.py",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "python-terminal.html#make-a-.py-file-as-a-module",
    "href": "python-terminal.html#make-a-.py-file-as-a-module",
    "title": "2Â  Run .py scripts with Bash",
    "section": "2.6 Make a .py file as a module",
    "text": "2.6 Make a .py file as a module\n\n2.6.1 Python module review\n Python modules and packages generally fall into four categories: built-in, standard library, third-party, and user-defined (see in FigureÂ 2.4). So far, youâ€™ve worked with the first three â€” modules that come with Python (e.g., datetime) or are installed from external sources (e.g., pandas).\n\n\n\n\n\n\nFigureÂ 2.4: Categories of Python Modules/Packages\n\n\n\n\n\n2.6.2 Create a user-defined Module in .py file\nIn this section, youâ€™ll learn how to create your own .py module with reuseable functions â€“ one that can be both imported into a Colab notebook and run independently for testing.\nCreate my_util.py in the scripts folder.\n# scripts/my_utils.py\n\ndef greet(name):\n    \"\"\"Return a personalized greeting.\"\"\"\n    return f\"Hello, {name}!\"\n\ndef add_numbers(a, b):\n    \"\"\"Return the sum of two numbers.\"\"\"\n    return a + b\n\n# many functions that you may want to re-use. \n\n# This block runs only if you execute `python my_utils.py`\n# This will make the .py file both run alone or import as a module\nif __name__ == \"__main__\":\n    print(\"Running my_utils.py as a standalone script...\")\n    print(greet(\"Tester\"))\n    print(\"5 + 7 =\", add_numbers(5, 7))\nOption 1: Run as a standalone .py file\npython scripts/my_utils.py\n\nOption 2: Run as a user-defined modules with reusable functions\nCreate a test_util.ipynb file in the same folder as your my_utils.py file. Then, you can do import my_utils to use it like any module/package that you have used before.\n\n\n\n\n\n\n\nNoteWhat does if __name__ == \"__main__\" do?\n\n\n\n__name__ is a special variable that Python automatically sets when a file is run or imported.\n\nIf the file is run directly (e.g., python my_utils.py), __name__ becomes \"__main__\".\nIf the file is imported (e.g., import my_utils), __name__ becomes the moduleâ€™s name (\"my_utils\").\nif __name__ == \"__main__\" ensures that code inside it runs only when the file is executed directly, not when imported. This allows a .py file to act as both:\n\na reusable module (when imported)\na standalone script for testing or demos (when run directly).\n\n\n\n\n\n\n\n\n\n\nNoteWhat if you remove the if __name__ == \"__main__\": line\n\n\n\nIf you do that, and then import the module, any code at the bottom of the file will run automatically during import, which can cause unwanted behavior (like printing, running tests, or altering data), see FigureÂ 2.5.\n\n\n\n\n\n\n\n\nFigureÂ 2.5: Removing __main__\n\n\n\nThe if __name__ == \"__main__\": line isnâ€™t required for a module to work, but it helps keep your code tidy and organized, allowing the file to be used both as a reusable module and as a standalone script with testing.\nYou also can import a single or multiple functions in a .py file.\n# import the greet(), add_numbers() functions\nfrom my_utils import greet, add_numbers\n\nprint(greet(\"Bob\"))           # Output: Hello, Bob!\nprint(add_numbers(10, 5))     # Output: 10 + 5 = 15\n\n\n2.6.3 Download .ipynb file as a .py file",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "streamlit.html",
    "href": "streamlit.html",
    "title": "3Â  Develop an app with streamlit",
    "section": "",
    "text": "3.1 Context and Goal\nData scientists often start in Jupyter Notebooks for exploration and analysis. However, real-world applications require deployable, interactive dashboards for sharing insights with others. The goal here is to:",
    "crumbs": [
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "streamlit.html#context-and-goal",
    "href": "streamlit.html#context-and-goal",
    "title": "3Â  Develop an app with streamlit",
    "section": "",
    "text": "ImportantGoal\n\n\n\nTransition from a prototype .ipynb file to a production-ready .py file that builds an interactive Streamlit dashboard.\n\n\n\n\nRefactor your notebook code into modular Python functions.\nWrap those functions inside an interactive Streamlit interface.\nUnderstand how to iterate quickly with streamlit run app.py.",
    "crumbs": [
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "streamlit.html#start-from-a-.ipynb-file",
    "href": "streamlit.html#start-from-a-.ipynb-file",
    "title": "3Â  Develop an app with streamlit",
    "section": "3.2 Start from a .ipynb file",
    "text": "3.2 Start from a .ipynb file\n\nDownload the following files from Canvas course.\n\nCompute Financial Ratios Notebook.ipynb â€“ a Jupyter Notebook\nsp500_data.csv â€“ Financial data.\nsp500_tickers.csv â€“ List of tickers.\n\nCreate a folder named streamlit25 in the default directory using bash command.\nDrag these three files into this folder in your browser.",
    "crumbs": [
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "streamlit.html#make-it-a-.py-file-with-functions",
    "href": "streamlit.html#make-it-a-.py-file-with-functions",
    "title": "3Â  Develop an app with streamlit",
    "section": "3.3 Make it a .py file with functions",
    "text": "3.3 Make it a .py file with functions\nThe syntax of defining a python function.\n\n\n1. Read the Compute Financial Ratios Notebook.ipynb\n2. Add a z-score metric seen in FigureÂ 3.1.\n\n\n\n\n\n\n\nFigureÂ 3.1: Z-score reference\n\n\n\n\n3. Make a empty finratios.py script file inside the same folder using bash command.\n4. Re-write the notebook code into reusable functions inside finratios.py\n\nâ€˜fetch_data_localâ€™\nfetch_data_local_single_ticker\ncalculate_metrics\nplot_trend\n\n\nGood practices:\n\nEach function should do one clear thing (e.g., load data, compute metrics, or plot)\nWhen writing functions, only use variables that come from the input parameters. If you need to use something inside the function, then make them input parameters.\n\n\n\n\n\n\n\nWarningâš ï¸ Be Careful with Function Inputs\n\n\n\nDonâ€™t rely on variables that arenâ€™t passed into your function.\nIf your function canâ€™t run using only its inputs, itâ€™s not truly reusable.\nâœ… Do this:\ndef compute_margin(revenue, cost):\n    return (revenue - cost) / revenue\nğŸš« Not this:\ntotal_revenue = 1000\ndef compute_margin(cost):\n    return (total_revenue - cost) / total_revenue  \n    # works in notebook, breaks in module\n\n\n\nDecide on return values.\n\nAdd a if __name__ == \"__main__\": for testing at the bottom of finratios.py, such as:\n\nif __name__ == \"__main__\":\n    # Simple test cases\n    print(compute_pe_ratio(1000000, 50000, 30))",
    "crumbs": [
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "streamlit.html#learn-a-bit-about-streamlit",
    "href": "streamlit.html#learn-a-bit-about-streamlit",
    "title": "3Â  Develop an app with streamlit",
    "section": "3.4 Learn a bit about Streamlit",
    "text": "3.4 Learn a bit about Streamlit\n\n\n\n\n\n\nTip\n\n\n\nYou donâ€™t know what Streamlit can do. Streamlit doesnâ€™t know what you want.\nBut, weâ€™ve gotta start somewhere.\nSo letâ€™s learn a bit. Once you know what it can do,\nyouâ€™ll finally know what you can make it do (with AIâ€™s help).\n\n\n\n\n\n\n\n\nTipHow learn to use a new Python package?\n\n\n\n\nWhat is Streamlit, and where is its API reference and official documentation?\nWhat can Streamlit do â€” what kinds of apps or problems is it best at solving?\nWhat small examples or experiments can I build to quickly discover and learn its core features?\n\n\n\n\nStart with the official docs and examples â€” skim the Streamlit docs homepage and gallery to get a mental map of whatâ€™s possible before diving into code.\nLearn by doing small experiments â€” build micro-apps (e.g., one with a button, one with a chart) to turn reading into muscle memory.\n\nE.g., create app1.py, app2.py files each to test and run some micro streamlit apps.\n\nRead code, not just tutorials â€” explore community demos or open-source Streamlit apps to see how others structure layouts, manage state, and handle inputs.\nIterate with feedback loops â€” run streamlit run app.py often and tweak one thing at a time; immediate visual feedback accelerates understanding.\nReflect and generalize â€” after each mini-project, note what patterns repeat (e.g., sidebar widgets, caching, layout control) to build knowledge for future tools.",
    "crumbs": [
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "streamlit.html#build-a-streamlit-app",
    "href": "streamlit.html#build-a-streamlit-app",
    "title": "3Â  Develop an app with streamlit",
    "section": "3.5 Build a Streamlit app",
    "text": "3.5 Build a Streamlit app\nHere is an example. Try to build a dashboard displaying the financial metrics interactively.\n\n\n\nAn Streamlit Example",
    "crumbs": [
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "streamlit.html#bonus-add-an-ai-feature",
    "href": "streamlit.html#bonus-add-an-ai-feature",
    "title": "3Â  Develop an app with streamlit",
    "section": "3.6 ğŸ’¡ Bonus: Add an AI Feature",
    "text": "3.6 ğŸ’¡ Bonus: Add an AI Feature\nIntegrate the Google Gemini API to enhance your app with AI-powered capabilities.\n\nExplore the API\nLearn how to use the Google Gemini API and follow the setup guide to install the SDK.\nGet an API Key\nYou can obtain a free API key using your Google account.\nKeep It Secure\nNever share or publish your API key on GitHub or any public platform â€” treat it like a password. Delete it after use.",
    "crumbs": [
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "1. Basic Command Line Crash Course",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "references.html#basic-command-line-crash-course",
    "href": "references.html#basic-command-line-crash-course",
    "title": "References",
    "section": "",
    "text": "Command Line Crash Course - Learn Python the Hard Way, Appendix A",
    "crumbs": [
      "References"
    ]
  }
]