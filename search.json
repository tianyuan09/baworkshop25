[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Business Analytics Workshop",
    "section": "",
    "text": "Welcome\n\nWelcome to the Business Analytics Workshop 2025!\nBuilding on prior exposure to programming and modeling fundamentals, this workshop focuses on real-world applications through cutting-edge tools like VS Code, Git, GitHub Copilot, and no-code/low-code AI agent platforms. You will engage with case-based exercises and live demonstrations to explore how modern data-driven teams collaborate, code, and build AI-enhanced solutions in agile business environments. This workshop seeks to bridge analytical modeling, modern software practices, and AI development workflows.\nThe material is prepared for the BA MBA Business Analytics Workshop.\nPlease do not cite or distribute without author‚Äôs permission.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "bash.html",
    "href": "bash.html",
    "title": "1¬† Command Lines and Terminal",
    "section": "",
    "text": "1.1 The Missing Piece\nMany students begin your programming journey by writing Python directly in platforms like Google Colab - no setup, no files, no terminals. These Jupyter notebook environments make coding easy; however, this convenience often means skipping an important part of programming: working with real Python files (.py) and using the terminal to run and manage code.\nThis ‚Äúmissing piece‚Äù is essential for understanding how programming works in real projects, servers, and production systems.\nSo, before diving deeper into advanced business data workflows, we‚Äôll start by filling this gap, and learn the command lines and terminal to navigate files, run Python scripts, and operate in professional computing environments.\nWhat You‚Äôll Learn Next",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#the-missing-piece",
    "href": "bash.html#the-missing-piece",
    "title": "1¬† Command Lines and Terminal",
    "section": "",
    "text": "Warning‚ö†Ô∏è Importance of Command Line and Terminal\n\n\n\nIf you skip learning command line skills or avoid the terminal, you‚Äôll struggle to work on real-world projects, collaborate effectively with teams, or operate in servers or cloud platforms ‚Äî where graphical interfaces aren‚Äôt available. The terminal isn‚Äôt just a tool for experts; it‚Äôs the foundation for professional workflows in data science and engineering.\n\n\n\n\n\nMain operating systems: Windows, macOS, Linux/Unix\nGUI vs terminal and why terminals matter\nBash shell basics for programming and data science",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#operating-systems-overview",
    "href": "bash.html#operating-systems-overview",
    "title": "1¬† Command Lines and Terminal",
    "section": "1.2 Operating Systems Overview",
    "text": "1.2 Operating Systems Overview\nMost students in this course use Windows, which dominates personal computers with roughly 70‚Äì75% of the global desktop market. macOS holds about 15‚Äì20%, while Linux and others make up a small share of personal use.\nIn contrast, the enterprise, cloud, AI/ML, and high-performance computing (HPC) worlds are very different. Linux and other Unix-like systems are the backbone in web servers, cloud computing and supercomputers, making up nearly half of cloud workloads and being the OS for all top 500 supercomputers. Popular Unix and Linux systems include:\n\nUbuntu\nDebian\nFedora\nRed Hat Enterprise Linux (RHEL)\n\n\n\n\n\n\n\nNotemacOS is Unix-based\n\n\n\nAlthough macOS looks different, it is actually Unix-based, meaning the terminal commands and Bash shell you‚Äôll learn in this course work much the same on both macOS and Linux.\n\n\n\nServers Linux holds a 62.7% market share for server operating systems.\n\nWeb servers: 77‚Äì88% of public web servers run on Linux or other Unix-like systems. It is the most used operating system for web servers globally.\n\nCloud computing Cloud workloads are heavily dependent on Linux-based operating systems. As of mid-2025, Linux powers 49.2% of all global cloud workloads.\nSupercomputers Linux has a complete monopoly in the supercomputing sector. 100% market share: Since 2017, 100% of the world‚Äôs top 500 supercomputers have run on Linux.\nAI and ML workloads Linux is the clear leader for AI and ML projects and infrastructure. In mid-2025, 87.8% of machine learning workloads ran on Linux infrastructure. Large ML and data science deployments predominantly run on Linux-based or Unix-based servers.\n\nCloud environments: Cloud providers like AWS, Google Cloud (GCP), Colab, and Microsoft Azure, which are leading providers for AI services, primarily offer Linux-based instances for running AI and ML tasks.\n\n\nSource: Wikipedia - Usage share of operating systems Azure Official Page, Microsoft Tech Community Update (Feb 2025)\n\n1.2.1 What Operating System does Google Colab use?\nLet‚Äôs take a look at what is the operating system (OS) that running Google Colab. You can type the following command lines in the Terminal.\n# Bash\n# Display info about the operating system\ncat /etc/*-release\n\n# Display the Linux kernel version and build info\ncat /proc/version\nSee image below for the outputs.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#what-is-a-terminal",
    "href": "bash.html#what-is-a-terminal",
    "title": "1¬† Command Lines and Terminal",
    "section": "1.3 What Is a Terminal?",
    "text": "1.3 What Is a Terminal?\n\nA terminal (also called a command line or shell) is a text-based interface that lets you interact directly with your computer by typing commands.\nBefore graphical interfaces (with windows, icons, and a mouse) were invented, the terminal was the primary way users operated computers ‚Äî to run programs, manage files, and control hardware.\nEVERY operating system includes a terminal app:\n\nWindows:\n\nCommand Prompt(cmd)\nPowerShell\nor Bash (through Windows Subsystem for Linux)\nLinux: Bash is the default shell on most Linux systems (see Colab terminal)\n\nmacOS: Zsh in Terminal app (based on Unix) is the default terminal in MacOS, see image below.\n\n\n\n\n\n\n\nNoteBash vs Zsh\n\n\n\n\nBoth Bash and Zsh are terminals that interpret your commands, and they work almost the same.\n\n\n\n\nThe terminal can do almost everything you normally do with a mouse:\n\nNavigate files and folders\n\nRun programs or scripts\n\nInstall and manage software\n\nConnect to remote servers\n\nAutomate repetitive tasks with shell scripts\n\nData scientists and developers rely on the terminal for its speed and automation, especially when working in cloud environments like Google Colab, GitHub codescpaces, or on Linux servers.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#why-learn-bash-commands-and-terminal",
    "href": "bash.html#why-learn-bash-commands-and-terminal",
    "title": "1¬† Command Lines and Terminal",
    "section": "1.4 Why Learn Bash commands and Terminal?",
    "text": "1.4 Why Learn Bash commands and Terminal?\nFirst, data science projects often run on servers or cloud environments, not personal laptops which lack the computational power for large-scale training, data processing, or deployment.\nThese servers ‚Äî such as AWS EC2, Azure VMs, or Google Cloud Compute instances ‚Äî usually run Linux or Unix systems and don‚Äôt include a graphical user interface (GUI) by default. ‚Äî they are managed entirely through the command line interface (CLI). To interact with them efficiently, you use Bash, a powerful and widely used command-line shell.\n\n\n\n\n\n\nTipWhat is a GUI?\n\n\n\nA Graphical User Interface (UI) is the visual part of your computer ‚Äî windows, buttons, and menus you click with the mouse. However, Linux servers don‚Äôt usually have this kind of visual interface.\nInstead, users interact with them through script commands typed into a terminal such as bash.\n\n\n\n1.4.1 GUI, CLI, Terminal and Desktop\n\n\nGUI (Graphical User Interface) ‚Äì The visual interface you use with a mouse, icons, and windows, such as Windows desktop, macOS Finder. GUIs are user-friendly but less efficient for automation or remote access.\nCLI (Command Line Interface) ‚Äì A text-based interface where you type commands instead of clicking.\nTerminal ‚Äì The program that provides access to the CLI. It‚Äôs like a window that lets you type commands and see text output, such as Windows PowerShell, macOS Terminal, Linux bash Terminal.\nDesktop Environment ‚Äì The collection of GUI components that make up the user‚Äôs graphical workspace ‚Äî including the taskbar, file explorer, and app windows; such as Windows Desktop, macOS.\n\n\n\n\n\n\n\nNoteSummary\n\n\n\n\nThe Terminal gives you access to the CLI, while the Desktop Environment provides a GUI.\n\nBoth let you control the same computer ‚Äî one through text, the other through graphics.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#learning-bash-commands-in-colab",
    "href": "bash.html#learning-bash-commands-in-colab",
    "title": "1¬† Command Lines and Terminal",
    "section": "1.5 Learning Bash commands in Colab",
    "text": "1.5 Learning Bash commands in Colab\nMastering Bash is essential. It enables you to write scripts, manage jobs, and execute commands directly on compute servers ‚Äî a critical skill when working with large datasets or LLM pipelines.\nWe are going to learn basic bash commands to:\n\nNavigate and manage files\nRun Python (.py) scripts and other programs (e.g., pip) directly from the command line\nWork efficiently within server-based or local terminal environments\n\nWe will use Google Colab to learn bash commands in Linux system.\nPlease create or open a new Colab notebook, and then open the Terminal panel.\n\n1.5.1 File Directory in Google Colab\nWhen you launch a new Colab notebook, the environment starts with a temporary Linux file system that looks like this:\n/\n‚îú‚îÄ‚îÄ bin/\n‚îú‚îÄ‚îÄ boot/\n‚îú‚îÄ‚îÄ content/\n‚îÇ   ‚îú‚îÄ‚îÄ drive/           ‚Üê your Google Drive (if mounted)\n‚îÇ   ‚îú‚îÄ‚îÄ sample_data/     ‚Üê sample datasets provided by Colab\n‚îÇ   ‚îî‚îÄ‚îÄ (your files)     ‚Üê any files you upload or create\n‚îú‚îÄ‚îÄ dev/\n‚îú‚îÄ‚îÄ etc/\n‚îú‚îÄ‚îÄ home/\n‚îÇ   ‚îî‚îÄ‚îÄ root/\n‚îú‚îÄ‚îÄ lib/\n‚îú‚îÄ‚îÄ media/\n‚îú‚îÄ‚îÄ mnt/\n‚îú‚îÄ‚îÄ opt/\n‚îú‚îÄ‚îÄ proc/\n‚îú‚îÄ‚îÄ root/                ‚Üê default home directory if you type `cd ~`\n‚îú‚îÄ‚îÄ run/\n‚îú‚îÄ‚îÄ sbin/\n‚îú‚îÄ‚îÄ srv/\n‚îú‚îÄ‚îÄ sys/\n‚îú‚îÄ‚îÄ tmp/\n‚îî‚îÄ‚îÄ usr/\n\n\n\n1.5.2 Lab: Linux and bash\n\nDisplay info about the operating system.\n\ncat /etc/*-release\n\nDisplay the Linux kernel version and build info.\n\ncat /proc/version\n\n\n1.5.3 Lab: Paths, Folders, Directories (pwd)\n\nPrint your current working directory (the folder you are ‚Äúin‚Äù). A directory is a folder, directory and folder are the same thing.\n\npwd\n#/content\nPlease type pwd 5 times and each time say ‚Äúprint working directory‚Äù.\nWhen to use pwd? if you lost in folders and don‚Äôt know where you are in the directories or folders, pwd will tell you where you are.\n/content# pwd\n#/content\n\n\n1.5.4 Lab: List Directory (ls)\nThe ls command is used to list files and folders in a directory.\nHere are some of the most commonly used ones with options (such as -a, -l)\n# List files and folders in the current directory\nls\n\n# List **all** files, including hidden ones (those starting with .)\nls -a\n\n# List files in a detailed (**long**) format ‚Äî shows permissions, owner, size, and date\nls -l\n\n# Combine options: show all files in detailed view\nls -la\n\n# Sort files by modification **time** (newest first)\nls -lt\n\n\n1.5.5 Lab: Change Directory (cd)\n\ncd sample_data: go the sample_data folder under the current directory.\ncd ..: go the parent folder.\ncd ~: go to the home folder. In Colab, the home folder is \\root. If you are lost in a directory and want to start over from a safe directory ‚Äì your home. You can type cd ~, and you will be taken to the home directory.\n\n# go into the sample_data folder\nls\ncd sample_data\nls\n\n\n# Move up one folder (to the parent directory /content)\ncd ..\n\n# Go back to your \"home\" folder (/root in Colab)\ncd ~\npwd\n\n# To-do: find a way to go back to the /content folder. \n\n\n\n1.5.6 Lab: Make A Directory (mkdir)\n# Create a new folder named \"data\" under /content \nmkdir data\n\n# Make multiple folders at once\nmkdir project scripts results\n\n# Check that they were created\nls\n\n\n1.5.7 Lab: curl\nGo to the \"data\" directory, and download a file from the internet. in curl -O &lt;URL&gt;, -O stands for saving file with the same name as on the web server.\n# Go to the \"data\" Directory\n\ncd data\n\n# Download a small sample text file and save it with the same name. \ncurl -O https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv\n\n# List files to confirm it‚Äôs there\nls\n\n\n1.5.8 Lab: Clear the Screen (clear)\n# Clear the terminal screen\nclear\n\n\n1.5.9 Lab: Remove Directory (rmdir)\n# Create an empty folder named \"temp_folder\"\nmkdir temp_folder\n\n# Remove the empty folder\nrmdir temp_folder\n\n# Create multiple empty folders and remove them\nmkdir folder1 folder2\nrmdir folder1 folder2\n\n\n1.5.10 Lab: Making Empty Files (touch)\n# Create an empty file named \"notes.txt\"\ntouch notes.txt\n\n# Create multiple files at once\ntouch a.txt b.txt c.txt\n\n# Verify files were created\nls\n\n\n1.5.11 Lab: Copy a File (cp)\n# Copy a file to a new file\ncp notes.txt notes_backup.txt\n\n# Create a folder to copy into\nmkdir backup\n\n# Copy a file into a different folder\ncp notes.txt backup/\n\n# Check the results\nls backup\n\n\n1.5.12 Lab: Moving/Rename a File (mv)\n# Move a file into a different folder\nmv notes_backup.txt backup/\n\n# Rename a file\nmv notes.txt todo.txt\n\n# Verify the changes\nls\n\n\n1.5.13 Lab: Stream a File (cat)\n# Display the contents of a file\ncat todo.txt\n\n# To-do: Display the README.md file in the \"sample_data\" folder:\n\n\n# Display a system file (try this!)\ncat /etc/*-release\n\n\n1.5.14 Lab: Removing a File (rm)\n# Create some temporary files first\ntouch old.txt temp.txt sample.txt\n\n# Remove a single file\nrm old.txt\n\n# Remove multiple files\nrm temp.txt sample.txt\n\n# Remove an entire folder and its contents (be careful!)\nrm -r backup\n\n\n1.5.15 Lab: Exiting Your Terminal (exit)\n# Exit the current terminal session\nexit",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#summary-table-common-bash-commands",
    "href": "bash.html#summary-table-common-bash-commands",
    "title": "1¬† Command Lines and Terminal",
    "section": "1.6 Summary Table ‚Äì Common Bash Commands",
    "text": "1.6 Summary Table ‚Äì Common Bash Commands\n\n\n\n\n\n\n\n\nCommand\nPurpose\nExample\n\n\n\n\npwd\nPrint working directory\npwd\n\n\nls\nList files and folders\nls -la\n\n\ncd\nChange directory\ncd /content\n\n\nmkdir\nMake a new directory\nmkdir data\n\n\nrmdir\nRemove an empty directory\nrmdir temp_folder\n\n\ncurl\nDownload a file from the internet\ncurl -O https://example.com/file.txt\n\n\ntouch\nCreate an empty file\ntouch notes.txt\n\n\ncp\nCopy a file\ncp notes.txt backup/\n\n\nmv\nMove or rename a file\nmv old.txt new.txt\n\n\ncat\nView contents of a file\ncat notes.txt\n\n\nrm\nRemove a file or folder\nrm -r foldername\n\n\nclear\nClear the screen\nclear\n\n\nexit\nExit the terminal\nexit",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "bash.html#h2-dir-in-codespaces",
    "href": "bash.html#h2-dir-in-codespaces",
    "title": "1¬† Command Lines and Terminal",
    "section": "1.7 Directory Structure in GitHub Codespace Terminal",
    "text": "1.7 Directory Structure in GitHub Codespace Terminal\n/\n‚îú‚îÄ‚îÄ bin/\n‚îú‚îÄ‚îÄ boot/\n‚îú‚îÄ‚îÄ dev/\n‚îú‚îÄ‚îÄ etc/\n‚îú‚îÄ‚îÄ home/\n‚îÇ   ‚îî‚îÄ‚îÄ codespace/          ‚Üê your user home directory if you do `cd ~`\n‚îú‚îÄ‚îÄ lib/\n‚îú‚îÄ‚îÄ lib64/\n‚îú‚îÄ‚îÄ media/\n‚îú‚îÄ‚îÄ mnt/\n‚îú‚îÄ‚îÄ opt/\n‚îú‚îÄ‚îÄ proc/\n‚îú‚îÄ‚îÄ root/\n‚îú‚îÄ‚îÄ run/\n‚îú‚îÄ‚îÄ sbin/\n‚îú‚îÄ‚îÄ srv/\n‚îú‚îÄ‚îÄ sys/\n‚îú‚îÄ‚îÄ tmp/\n‚îú‚îÄ‚îÄ usr/\n‚îî‚îÄ‚îÄ workspaces/\n    ‚îî‚îÄ‚îÄ /codespaces-jupyter     ‚Üê your GitHub repo (default working dir)\n\n\n1.7.1 Bash in VS codespaces\nRestart your github codespaces.\n\nMake sure your can see the Terminal panel. If you accidently closed your terminal, you can always start one (or many) following the steps below.\n\nYou also can start a second terminal via the Terminal panel.\n\n\n\n1.7.2 Lab: create the scripts folder\nUsing the bash terminal to create a scripts folder under GitHub default working dir /workspaces/codespaces-jupyter, and create an empty my_script.py file in the scripts folder.\n\n\n\n\n\n\nTipTip\n\n\n\nYou may find the commands pwd, mkdir, ls, cd, and touch helpful for completing this exercise.\n\n\nYour task is to:\n\nVerify your current working directory.\n\nCreate a new folder called scripts inside the project root.\n\nList the directory contents to confirm that scripts was created successfully.\n\nNavigate into the scripts folder.\n\nConfirm it is empty.\n\nCreate a new Python file named my_script.py inside the scripts folder.\n\nWrite the Bash commands needed to accomplish each step.\nOnce you complete the task, your explorer should look like below:\n\n\n\n\n\n\n\nCautionSolution\n\n\n\n\n\n@tianyuan09 ‚ûú /workspaces/codespaces-jupyter (main) $ pwd\n/workspaces/codespaces-jupyter\n@tianyuan09 ‚ûú /workspaces/codespaces-jupyter (main) $ mkdir scripts\n@tianyuan09 ‚ûú /workspaces/codespaces-jupyter (main) $ ls\nLICENSE  README.md  data  notebooks  requirements.txt  scripts\n@tianyuan09 ‚ûú /workspaces/codespaces-jupyter (main) $ cd scripts\n@tianyuan09 ‚ûú /workspaces/codespaces-jupyter/scripts (main) $ ls\n@tianyuan09 ‚ûú /workspaces/codespaces-jupyter/scripts (main) $ touch my_script.py",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Command Lines and Terminal</span>"
    ]
  },
  {
    "objectID": "python-terminal.html",
    "href": "python-terminal.html",
    "title": "2¬† Run .py scripts with Bash",
    "section": "",
    "text": "2.1 Why Run Python Scripts from Terminal?\nWhile interactive environments like Jupyter notebooks are great for exploration and prototyping, running Python scripts (.py files) from the terminal is essential for:",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "python-terminal.html#why-run-python-scripts-from-terminal",
    "href": "python-terminal.html#why-run-python-scripts-from-terminal",
    "title": "2¬† Run .py scripts with Bash",
    "section": "",
    "text": "Production workflows: Automated data processing, model training, and deployment\nServer environments: Most servers don‚Äôt have graphical interfaces\nBatch processing: Running scripts on large datasets or multiple files\nScheduling: Using cron jobs or task schedulers to run scripts automatically\nCommand-line arguments: Passing parameters to scripts dynamically\nPerformance: Scripts often run faster than notebooks for large tasks\n\n\n\n\n\n\n\nNoteFor Example\n\n\n\nData scientists often submit training jobs via Bash scripts like:\npython train_model.py --epochs 10\nIt runs the Python script train_model.py to train the model for 10 epochs.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "python-terminal.html#ipynb-notebook-vs-.py-script-files",
    "href": "python-terminal.html#ipynb-notebook-vs-.py-script-files",
    "title": "2¬† Run .py scripts with Bash",
    "section": "2.2 .ipynb Notebook vs .py Script Files",
    "text": "2.2 .ipynb Notebook vs .py Script Files\nFigure¬†2.1 illustrates the difference between running Python code in .ipynb notebook versus in `.py‚Äô script file.\n\n\n\n\n\n\nFigure¬†2.1: Comparison of Jupyter Notebook and Python Script formats\n\n\n\nUnderstanding the Terminal\nSee directory structure in codespaces in the previous chapter.\nIn the terminal, it always starts with:\n\n@tianyuan09 ‚ûú /workspaces/codespaces-jupyter (main) $.\n\n@tianyuan09 ‚ûú /workspaces/codespaces-jupyter (main) $\n‚îÇ           ‚îÇ                 ‚îÇ                   ‚îÇ\n‚îÇ           ‚îÇ                 ‚îÇ                   ‚îî‚îÄ Prompt symbol ($): \n‚îÇ           ‚îÇ                 ‚îÇ                      shows the terminal is ready for input\n‚îÇ           ‚îÇ                 ‚îÇ\n‚îÇ           ‚îÇ                 ‚îî‚îÄ Current working directory:\n‚îÇ           ‚îÇ                    you‚Äôre inside the folder ‚Äúcodespaces-jupyter‚Äù\n‚îÇ           ‚îÇ                    located under ‚Äú/workspaces‚Äù\n‚îÇ           ‚îÇ\n‚îÇ           ‚îî‚îÄ Arrow (‚ûú): \n‚îÇ               just a decorative separator in the prompt\n‚îÇ\n‚îî‚îÄ Username (and sometimes host): \n   ‚Äútianyuan09‚Äù ‚Äî the current user logged into this environment\nDifference between .ipynb Notebook and .py Script File.\n\n\n\n\n\n\n\n\nFeature\n.ipynb (Jupyter Notebook)\n.py (Python Script)\n\n\n\n\nStructure\nStructured JSON format combining code, text cells in Markdown, and outputs.\nPlain text file containing only Python code and comments #.\n\n\nExecution\nRun one cell at a time, showing output immediately below each cell.\nExecuted all at once using a command like python my_script.py, seen ‚ë£ in Figure¬†2.1.\n\n\nUse Case\nIdeal for data analysis, visualization, and teaching due to its interactive nature.\nBetter for automation, deployment of production-ready code.\n\n\n\n\n2.2.1 Lab: Create and run a .py script file\nFirst, let‚Äôs create a hello.py under the scripts folder.\n# file path: scripts/hello.py\nprint(\"Hello from Python!\")\nprint(\"This script is running from the terminal.\")\n\n# Get current date and time\nimport datetime\nnow = datetime.datetime.now()\nprint(f\"Current time: {now}\")\nYou can directly use explorer or use bash command Figure¬†2.2.\n\n\n\n\n\n\nFigure¬†2.2: Create and run your 1st script file\n\n\n\nExpected output:\nHello from Python!\nThis script is running from the terminal.\nCurrent time: 2025-10-13 10:30:45.123456",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "python-terminal.html#other-python-related-commmands",
    "href": "python-terminal.html#other-python-related-commmands",
    "title": "2¬† Run .py scripts with Bash",
    "section": "2.3 Other Python-related Commmands",
    "text": "2.3 Other Python-related Commmands\n\n2.3.1 Checking Your Python Version\n# Check Python version\npython --version\npython3 --version\n\n# Check which Python executable you're using\nwhich python\nwhich python3\n\n\n2.3.2 Different Python Commands\nDepending on your system setup, you might need to use different commands:\n# On systems with Python 3 as default\npython hello.py\n\n# OR\npython3 hello.py\n\n# OR Using specific Python version\npython3.9 hello.py\npython3.12 hello.py\n\n\n2.3.3 Running pip command\n\n\n\n\n\n\nImportantTip\n\n\n\npip is a command-line tool, not Python code. You actually should run pip install ... in your terminal.\n\n\nAlthough you have run pip inside a code cell in Colab with !, such as !pip install pandas, the notebook actually sends it as a command line to the terminal to execute. It is equivalent to running pip install pandas in the terminal, see in Figure¬†2.3.\n\n\n\n\n\n\nFigure¬†2.3: pip in terminal\n\n\n\n\n\n\n\n\n\nImportantHow to install package for .py files?\n\n\n\nIn regular .py files (non-notebook files), pip commands must be executed in the terminal, not inside the script itself.\nFor example, to install the streamlit package, run this in your terminal:\npip install streamlit\n\n\n\nList all the packages installed:\n# Check installed packages\npip list\nPlease install streamlit in your codespaces.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "python-terminal.html#working-with-command-line-arguments",
    "href": "python-terminal.html#working-with-command-line-arguments",
    "title": "2¬† Run .py scripts with Bash",
    "section": "2.4 Working with Command-Line Arguments",
    "text": "2.4 Working with Command-Line Arguments\n\n2.4.1 Creating a Script with Arguments\n.py files with arguments allow the users to provide input directly when running the script. Please work on the following example.\n# create and save in scripts/greet.py\nimport sys\nprint(sys.argv) # sys.argv is a list of string typed after python in the bash\n\n# Check if arguments were provided\nif len(sys.argv) &lt; 2:\n    print(\"Usage: python greet.py &lt;name&gt;\")\n    sys.exit(1)\n\nname = sys.argv[1]\nprint(f\"Hello, {name}!\")\n\n# Optional: Handle multiple arguments\nif len(sys.argv) &gt; 2:\n    age = sys.argv[2]\n    print(f\"You are {age} years old.\")\n\n\n2.4.2 Running with Arguments\n# Run with one argument\npython greet.py Alice\n\n# Run with multiple arguments\npython greet.py Bob 25\n\n# Without arguments (will show usage message)\npython greet.py\n\n\n2.4.2.1 sys.argv ‚Äî what it really is\nsys.argv is a list of strings containing everything typed after python in the terminal.\nFor example, if you run:\npython greet.py Alice 25\nThen in Python:\nimport sys\nprint(sys.argv)\n# output: ['greet.py', 'Alice', '25'] # a list\n\n\n2.4.2.2 Index meaning\n\n\n\n\n\n\n\n\nIndex\nValue\nMeaning\n\n\n\n\nsys.argv[0]\n'greet.py'\nthe name of the script file being executed\n\n\nsys.argv[1]\n'Alice'\nthe first argument typed after the script name\n\n\nsys.argv[2]\n'25'\nthe second argument (if given)\n\n\n\n\n\n2.4.2.3 why name = sys.argv[1]?\nBecause:\n\nsys.argv[0] is always the script name (greet.py)\nsys.argv[1] is the first real argument that the user provides. In this case, the person‚Äôs name.\n\nIf you used sys.argv[0], it would just say: Hello, greet.py!",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "python-terminal.html#running-scripts-in-different-directories.",
    "href": "python-terminal.html#running-scripts-in-different-directories.",
    "title": "2¬† Run .py scripts with Bash",
    "section": "2.5 Running Scripts in Different Directories.",
    "text": "2.5 Running Scripts in Different Directories.\n\n2.5.1 Absolute Paths\n# Run script from anywhere using absolute path\npython /Users/username/projects/my_script.py\n/Users/username/projects/my_script.py is a absolute file path.\nAbsolute paths:\n\nOn macOS/Linux, starts with /.\nOn Windows, starts with a drive letter like C:/.\nIn short, it always starts from the root of the filesystem (the top level).\n\nYou can find either the relative or aboslute file paths in codespaces:\n\n\n\n2.5.2 Relative Paths\n# Run script in current directory\npython ./script.py\n\n# Run script in subdirectory\npython scripts/data_analysis.py\n\n# Run script in parent directory\npython ../utilities/helper.py\nThe paths above (e.g.¬†../utilities/helper.py) are relative paths.\n\nThey don‚Äôt start with / or a drive letter (e.g.¬†C:/).\nThey may include . (current folder) or .. (parent folder).\nThey starts from your current working directory (pwd).\n\n\n\n2.5.3 Difference in absolute vs relative paths\n\n\n\nStarts With\nType\nMeaning\n\n\n\n\n/ (Linux/Mac)\nAbsolute\nStarts at root of file system\n\n\nC:\\ (Windows)\nAbsolute\nStarts at root of drive\n\n\n. or ..\nRelative\nBased on current working directory\n\n\nNo / or C:\\\nRelative\nImplied to start from current folder\n\n\n\n\n\n2.5.4 Changing Directories\n# Navigate to script directory, then run\ncd /path/to/scripts\npython analysis.py\n\n# Or combine in one line\ncd /path/to/scripts && python analysis.py",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "python-terminal.html#make-a-.py-file-as-a-module",
    "href": "python-terminal.html#make-a-.py-file-as-a-module",
    "title": "2¬† Run .py scripts with Bash",
    "section": "2.6 Make a .py file as a module",
    "text": "2.6 Make a .py file as a module\n\n2.6.1 Python module review\n Python modules and packages generally fall into four categories: built-in, standard library, third-party, and user-defined (see in Figure¬†2.4). So far, you‚Äôve worked with the first three ‚Äî modules that come with Python (e.g., datetime) or are installed from external sources (e.g., pandas).\n\n\n\n\n\n\nFigure¬†2.4: Categories of Python Modules/Packages\n\n\n\n\n\n2.6.2 Create a user-defined Module in .py file\nIn this section, you‚Äôll learn how to create your own .py module with reuseable functions ‚Äì one that can be both imported into a Colab notebook and run independently for testing.\nCreate my_util.py in the scripts folder.\n# scripts/my_utils.py\n\ndef greet(name):\n    \"\"\"Return a personalized greeting.\"\"\"\n    return f\"Hello, {name}!\"\n\ndef add_numbers(a, b):\n    \"\"\"Return the sum of two numbers.\"\"\"\n    return a + b\n\n# many functions that you may want to re-use. \n\n# This block runs only if you execute `python my_utils.py`\n# This will make the .py file both run alone or import as a module\nif __name__ == \"__main__\":\n    print(\"Running my_utils.py as a standalone script...\")\n    print(greet(\"Tester\"))\n    print(\"5 + 7 =\", add_numbers(5, 7))\nOption 1: Run as a standalone .py file\npython scripts/my_utils.py\n\nOption 2: Run as a user-defined modules with reusable functions\nCreate a test_util.ipynb file in the same folder as your my_utils.py file. Then, you can do import my_utils to use it like any module/package that you have used before.\n\n\n\n\n\n\n\nNoteWhat does if __name__ == \"__main__\" do?\n\n\n\n__name__ is a special variable that Python automatically sets when a file is run or imported.\n\nIf the file is run directly (e.g., python my_utils.py), __name__ becomes \"__main__\".\nIf the file is imported (e.g., import my_utils), __name__ becomes the module‚Äôs name (\"my_utils\").\nif __name__ == \"__main__\" ensures that code inside it runs only when the file is executed directly, not when imported. This allows a .py file to act as both:\n\na reusable module (when imported)\na standalone script for testing or demos (when run directly).\n\n\n\n\n\n\n\n\n\n\nNoteWhat if you remove the if __name__ == \"__main__\": line\n\n\n\nIf you do that, and then import the module, any code at the bottom of the file will run automatically during import, which can cause unwanted behavior (like printing, running tests, or altering data), see Figure¬†2.5.\n\n\n\n\n\n\n\n\nFigure¬†2.5: Removing __main__\n\n\n\nThe if __name__ == \"__main__\": line isn‚Äôt required for a module to work, but it helps keep your code tidy and organized, allowing the file to be used both as a reusable module and as a standalone script with testing.\nYou also can import a single or multiple functions in a .py file.\n# import the greet(), add_numbers() functions\nfrom my_utils import greet, add_numbers\n\nprint(greet(\"Bob\"))           # Output: Hello, Bob!\nprint(add_numbers(10, 5))     # Output: 10 + 5 = 15\n\n\n2.6.3 Download .ipynb file as a .py file",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Run `.py` scripts with Bash</span>"
    ]
  },
  {
    "objectID": "streamlit.html",
    "href": "streamlit.html",
    "title": "3¬† Develop an app with streamlit",
    "section": "",
    "text": "3.1 Context and Goal\nData scientists often start in Jupyter Notebooks for exploration and analysis. However, real-world applications require deployable, interactive dashboards for sharing insights with others. The goal here is to:",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "streamlit.html#context-and-goal",
    "href": "streamlit.html#context-and-goal",
    "title": "3¬† Develop an app with streamlit",
    "section": "",
    "text": "ImportantGoal\n\n\n\nTransition from a prototype .ipynb file to a production-ready .py file that builds an interactive Streamlit dashboard.\n\n\n\n\nRefactor your notebook code into modular Python functions.\nWrap those functions inside an interactive Streamlit interface.\nUnderstand how to iterate quickly with streamlit run app.py.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "streamlit.html#start-from-a-.ipynb-file",
    "href": "streamlit.html#start-from-a-.ipynb-file",
    "title": "3¬† Develop an app with streamlit",
    "section": "3.2 Start from a .ipynb file",
    "text": "3.2 Start from a .ipynb file\n\nDownload the following files from Canvas course.\n\nCompute Financial Ratios Notebook.ipynb ‚Äì a Jupyter Notebook\nsp500_data.csv ‚Äì Financial data.\nsp500_tickers.csv ‚Äì List of tickers.\n\nCreate a folder named streamlit25 in the default directory using bash command.\nDrag these three files into this folder in your browser.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "streamlit.html#make-it-a-.py-file-with-functions",
    "href": "streamlit.html#make-it-a-.py-file-with-functions",
    "title": "3¬† Develop an app with streamlit",
    "section": "3.3 Make it a .py file with functions",
    "text": "3.3 Make it a .py file with functions\nThe syntax of defining a python function.\n\n\n1. Read the Compute Financial Ratios Notebook.ipynb\n2. Add a z-score metric seen in Figure¬†3.1.\n\n\n\n\n\n\n\nFigure¬†3.1: Z-score reference\n\n\n\n\n3. Make a empty finratios.py script file inside the same folder using bash command.\n4. Re-write the notebook code into reusable functions inside finratios.py\n\n‚Äòfetch_data_local‚Äô\nfetch_data_local_single_ticker\ncalculate_metrics\nplot_trend\n\n\nGood practices:\n\nEach function should do one clear thing (e.g., load data, compute metrics, or plot)\nWhen writing functions, only use variables that come from the input parameters. If you need to use something inside the function, then make them input parameters.\n\n\n\n\n\n\n\nWarning‚ö†Ô∏è Be Careful with Function Inputs\n\n\n\nDon‚Äôt rely on variables that aren‚Äôt passed into your function.\nIf your function can‚Äôt run using only its inputs, it‚Äôs not truly reusable.\n‚úÖ Do this:\ndef compute_margin(revenue, cost):\n    return (revenue - cost) / revenue\nüö´ Not this:\ntotal_revenue = 1000\ndef compute_margin(cost):\n    return (total_revenue - cost) / total_revenue  \n    # works in notebook, breaks in module\n\n\n\nDecide on return values.\n\nAdd a if __name__ == \"__main__\": for testing at the bottom of finratios.py, such as:\n\nif __name__ == \"__main__\":\n    # Simple test cases\n    print(compute_pe_ratio(1000000, 50000, 30))",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "streamlit.html#learn-a-bit-about-streamlit",
    "href": "streamlit.html#learn-a-bit-about-streamlit",
    "title": "3¬† Develop an app with streamlit",
    "section": "3.4 Learn a bit about Streamlit",
    "text": "3.4 Learn a bit about Streamlit\n\n\n\n\n\n\nTip\n\n\n\nYou don‚Äôt know what Streamlit can do. Streamlit doesn‚Äôt know what you want.\nBut, we‚Äôve gotta start somewhere.\nSo let‚Äôs learn a bit. Once you know what it can do,\nyou‚Äôll finally know what you can make it do (with AI‚Äôs help).\n\n\n\n\n\n\n\n\nTipHow learn to use a new Python package?\n\n\n\n\nWhat is Streamlit, and where is its API reference and official documentation?\nWhat can Streamlit do ‚Äî what kinds of apps or problems is it best at solving?\nWhat small examples or experiments can I build to quickly discover and learn its core features?\n\n\n\n\nStart with the official docs and examples ‚Äî skim the Streamlit docs homepage and gallery to get a mental map of what‚Äôs possible before diving into code.\nLearn by doing small experiments ‚Äî build micro-apps (e.g., one with a button, one with a chart) to turn reading into muscle memory.\n\nE.g., create app1.py, app2.py files each to test and run some micro streamlit apps.\n\nRead code, not just tutorials ‚Äî explore community demos or open-source Streamlit apps to see how others structure layouts, manage state, and handle inputs.\nIterate with feedback loops ‚Äî run streamlit run app.py often and tweak one thing at a time; immediate visual feedback accelerates understanding.\nReflect and generalize ‚Äî after each mini-project, note what patterns repeat (e.g., sidebar widgets, caching, layout control) to build knowledge for future tools.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "streamlit.html#build-a-streamlit-app",
    "href": "streamlit.html#build-a-streamlit-app",
    "title": "3¬† Develop an app with streamlit",
    "section": "3.5 Build a Streamlit app",
    "text": "3.5 Build a Streamlit app\nHere is an example. Try to build a dashboard displaying the financial metrics interactively.\n\n\n\nAn Streamlit Example",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "streamlit.html#bonus-add-an-ai-feature",
    "href": "streamlit.html#bonus-add-an-ai-feature",
    "title": "3¬† Develop an app with streamlit",
    "section": "3.6 üí° Bonus: Add an AI Feature",
    "text": "3.6 üí° Bonus: Add an AI Feature\nIntegrate the Google Gemini API to enhance your app with AI-powered capabilities.\n\nExplore the API\nLearn how to use the Google Gemini API and follow the setup guide to install the SDK.\nGet an API Key\nYou can obtain a free API key using your Google account.\nKeep It Secure\nNever share or publish your API key on GitHub or any public platform ‚Äî treat it like a password. Delete it after use.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Develop an app with `streamlit`</span>"
    ]
  },
  {
    "objectID": "vscodecopilot.html",
    "href": "vscodecopilot.html",
    "title": "4¬† VS Code with Copilot Chat",
    "section": "",
    "text": "4.1 A Quick Recap: VS Code, Colab and Your Python Environments\nYou have used VS Code with Copilot in Github codespaces to develop a dashboard app. Let‚Äôs recap on a few basics based on your experience.\nYou also can set up the same development environment in your local PC. You will need to install multiple softwares and tools, such as Python, VS Code, Python extension in VS Code, and each python package that you might use (such as pandas).",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>VS Code with Copilot Chat</span>"
    ]
  },
  {
    "objectID": "vscodecopilot.html#a-quick-recap-vs-code-colab-and-your-python-environments",
    "href": "vscodecopilot.html#a-quick-recap-vs-code-colab-and-your-python-environments",
    "title": "4¬† VS Code with Copilot Chat",
    "section": "",
    "text": "Each Github Codespace runs on a Linux virtual machine that already has tools like Python, Jupyter Notebook support, various packages, and VS Code (via the web interface) preinstalled. When you open a Codespace, you‚Äôre actually using VS Code running in your browser, connected to that remote Linux machine. So:\n\nCodespaces = a Linux system in the cloud + Python + JupyterLab + various Python packages + VS Code (IDE interface).\n\nEach Google Colab notebook, on the other hand, also provides a Linux-based environment with Python and Jupyter Notebooks, but it doesn‚Äôt include VS Code.\n\nColab = a Linux system in the cloud + Python + JupyterLab + various python packages.\n\n\n\n\n\n\n\n\nNoteWhy VS Code is not in Colab Notebook?\n\n\n\nVS Code is a Microsoft product, while Colab is a Google product ‚Äî and it‚Äôs unlikely Google would integrate a direct competitor‚Äôs tool into its own cloud platform.\n\n\n\n\n\n\n\n\n\n\n\nEnvironment\nWhat it includes\nNotes\n\n\n\n\nCodespaces\nLinux + Python + Jupyter + various packages + VS Code (web)\nCloud-hosted; nothing to install locally; runs VS code interface\n\n\nColab\nLinux + Python + Jupyter + various packages\nCloud-hosted; focuses on notebook interface\n\n\nLocal PC\nWhatever you install (Python, VS Code, Jupyter)\nRuns directly on your machine",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>VS Code with Copilot Chat</span>"
    ]
  },
  {
    "objectID": "vscodecopilot.html#github-copilot-and-copilot-chat-ask-edit-and-agent-modes",
    "href": "vscodecopilot.html#github-copilot-and-copilot-chat-ask-edit-and-agent-modes",
    "title": "4¬† VS Code with Copilot Chat",
    "section": "4.2 GitHub Copilot and Copilot Chat: Ask, Edit and Agent Modes",
    "text": "4.2 GitHub Copilot and Copilot Chat: Ask, Edit and Agent Modes\nYou have used Copilot on Day 1 for development of a dashboard using streamlit. let‚Äôs review features of GitHub Copilot and Copilot Chat.\nGitHub Copilot comes with four distant modes that you may use:\n\nInline Chat or suggestions: quick in-context code suggestions directly within VS Code using shortcuts ‚åò+I or Ctrl+I.\n\n\n\nAsk Mode: best for Q&A. Highlight some code, then ask Copilot questions about its logic, purpose, or braistorm ideas implementation.\nEdit Mode: give you inline, review-ready code edits across the files.\nAgent Mode: an autonomous mode where Copilot analyzes context (e.g., files in your workspace) and performs tasks based on your request.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>VS Code with Copilot Chat</span>"
    ]
  },
  {
    "objectID": "vscodecopilot.html#tips-for-using-the-copilot-agent-mode",
    "href": "vscodecopilot.html#tips-for-using-the-copilot-agent-mode",
    "title": "4¬† VS Code with Copilot Chat",
    "section": "4.3 Tips for Using the Copilot Agent Mode",
    "text": "4.3 Tips for Using the Copilot Agent Mode\nTo get the best results in Agent Mode, you can provide additional context or use special commands to guide Copilot about what you want it to do.\n\n\n\n\n\n\nNoteWhat is ‚ÄúContext‚Äù?\n\n\n\nContext is the information you give Copilot so it understands what you‚Äôre working on and can respond more accurately. In Agent Mode, context can include the code you‚Äôve selected, other .py files, or any extra notes you write with #.\n\n\n\nHighlight code (e.g., line 57-59 of the vscodecopilot.qmd file) in the file will automatically add those lines of code in the context (see Figure¬†4.1)\nAdd context with #. Add additional files that you want Copilot to read before completing the task.\ncommands with /. E.g. /explain is a command asking for explanation of the code.\n\n\n\n\n\n\n\nFigure¬†4.1: Highlight code, or add contexts or commands",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>VS Code with Copilot Chat</span>"
    ]
  },
  {
    "objectID": "vscodecopilot.html#reflections-on-ai-in-development-workflows",
    "href": "vscodecopilot.html#reflections-on-ai-in-development-workflows",
    "title": "4¬† VS Code with Copilot Chat",
    "section": "4.4 Reflections on AI in Development Workflows",
    "text": "4.4 Reflections on AI in Development Workflows\n\n4.4.1 Vibe-coding vs AI-assisted Coding\nOn Day 1, if you used Agent Mode in Copilot to build your Streamlit app ‚Äî without reading or understanding any of the code ‚Äî you were vibe-coding. You relied on the AI to produce something that looked right without knowing how it actually worked.\nHowever, if you read, wrote, or edited the code while building the app, you were doing AI-assisted coding ‚Äî working with the AI to shape logic, fix bugs, and design structure.\n\n\n\n\n\n\n\n\nAspect\nVibe Coding\nAI-Assisted Coding\n\n\n\n\nDefinition\nA no-code workflow where you don‚Äôt read, write, or edit code. You simply test the prototype or app to see if it meets your design or intent.\nA coding workflow where you interact with and modify code using AI tools like Copilot‚Äôs Ask, Edit, or Inline Chat.\n\n\nGoal\nValidate the ‚Äúvibe‚Äù ‚Äî check if the prototype looks, feels, and behaves as intended.\nBuild, refine, and ship production-ready features with AI support.\n\n\nUser Interaction\nNo direct code manipulation ‚Äî focus is on results, not implementation.\nActively generate, read, edit, debug, and review code and suggestions with AI\n\n\nAI Tools\nGitHub Copilot Agent Mode\nGitHub Copilot Ask Mode, Edit Mode, Inline Chat\n\n\nMindset\n‚ÄúI don‚Äôt care how it‚Äôs built ‚Äî does it look and work as intended?‚Äù\n‚ÄúI‚Äôll collaborate with AI to understand, fix, or enhance the code.‚Äù\n\n\nBest For\nRapid prototyping, early design validation\nFull-cycle software or data product development: feature implementation, optimization, and maintenance.\n\n\nLimitations.\nIgnores the complexity, lacks of consideration over performance, scalability, and maintainability.\nSupports real data engineering work but still requires developer understanding and validation\n\n\n\n\nI was vibe-coding\nI was doing AI-assisted coding\n\nBoth Vibe-coding and AI-assisted coding have their place in development. Use vibe-coding for quick validation and prototyping, and AI-assisted coding for building robust, production-ready data science solutions.\nAlthough vibe-coding feels exciting, you can‚Äôt rely on it from prototype to production, as it often makes mistakes or produces ‚Äúshit code‚Äù ‚Äî duplicated logic, buggy and insecure implementations, and tangled features no one dares to maintain. In data science, that might look like a notebook full of hard-coded file paths, random seeds, and global variables ‚Äî impossible to reproduce or scale.\n\nAlso, don‚Äôt fool yourself into thinking you‚Äôre learning to code while working in Agent Mode ‚Äî you‚Äôre NOT building the skills yourself. You can‚Äôt learn guitar just by watching someone else play, and you can‚Äôt learn piano by watching performances. Likewise, you can‚Äôt truly learn programming just by watching an Agent write code for you. The craft lies in understanding, experimenting, and making mistakes. That‚Äôs how you move from vibe-coding prototypes to engineered, production-ready solutions.\n\n\n4.4.2 Why the Basics Still Matters?\n\nWhy isn‚Äôt vibe coding enough for real-world data science projects?\n\nWhile vibe coding can accelerate prototyping and help non-technical users validate design ideas, it often overlooks many critical aspects of data engineering ‚Äî such as scalability, performance, maintainability, and security. Building reliable data science solution or product remains a complex, multi-layered process that requires thoughtful coding, testing, and collaboration between designers, developers, and AI tools.\n\n\n\n\n\n\nImportantBest tip for using AI:\n\n\n\nStay focused on what really matters ‚Äî let AI speed up the work, but make sure you‚Äôre the one driving the direction, decisions, and understanding.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>VS Code with Copilot Chat</span>"
    ]
  },
  {
    "objectID": "aifeature.html",
    "href": "aifeature.html",
    "title": "5¬† Build Applications with LLMs and AI Agents",
    "section": "",
    "text": "5.1 Understanding API vs.¬†Chat in AI Tools\nMany of you have already used AI chat tools like ChatGPT or Gemini Chat to ask questions, write code snippets, or brainstorm ideas. That‚Äôs the user experience ‚Äî you‚Äôre communicating with the model to get answers.\nBut when you start using LLMs and AI agents for development, the perspective changes completely. Instead of talking to the AI, you‚Äôre now building with it. You‚Äôre no longer just a user ‚Äî you become a developer who leverages the model‚Äôs power through APIs to create tools, automate workflows, or build intelligent apps.\nThe table below compares OpenAI‚Äôs ChatGPT and Google‚Äôs Gemini platforms, highlighting the difference between their APIs (used by developers to build applications) and their chat interfaces (used by end users to interact with the models).",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Build Applications with LLMs and AI Agents</span>"
    ]
  },
  {
    "objectID": "aifeature.html#understanding-api-vs.-chat-in-ai-tools",
    "href": "aifeature.html#understanding-api-vs.-chat-in-ai-tools",
    "title": "5¬† Build Applications with LLMs and AI Agents",
    "section": "",
    "text": "Aspect\nOpenAI API\nChatGPT (OpenAI)\nGemini API\nGemini Chat\n\n\n\n\nType\nDeveloper API\nChat Interface\nDeveloper API\nChat Interface\n\n\nPurpose\nBuild apps or tools using GPT models (e.g., GPT-4).\nChat directly with GPT models for writing, coding, or learning.\nBuild apps or workflows using Gemini models.\nChat naturally with Gemini for assistance or ideas.\n\n\nHow It‚Äôs Used\nThrough code (Python, JS, etc.).\nThrough a chat interface (web or app).\nThrough code (Google AI Studio or Vertex AI).\nThrough chat (Gemini web app, Workspace integration).\n\n\nUsers\nDevelopers, researchers.\nGeneral users, educators, professionals.\nDevelopers, data teams.\nStudents, creators, general users.\n\n\nExample Use\nA developer calls GPT-4 via API to generate summaries or analyze data.\nYou ask ‚ÄúExplain this regression code.‚Äù\nA data app uses Gemini API to summarize Google Sheets data.\nYou ask Gemini, ‚ÄúVisualize this dataset for me.‚Äù\n\n\nOutput Control\nFully customizable ‚Äî responses formatted via code.\nNatural text output in chat.\nFully customizable ‚Äî can return text, JSON, or structured data.\nConversational responses, plain text or visuals.\n\n\nGoal\nBuild with the model.\nTalk to the model.\nBuild with the model.\nTalk to the model.\n\n\n\n\n\n\n\n\n\nWarningSummary\n\n\n\n\nAPIs are for developers ‚Äî you use them to build apps with AI features for the end users.\nChat tools are for the end users ‚Äî you chat with the model to get answers.\nOpenAI powers ChatGPT; Google powers Gemini; different ecosystems.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Build Applications with LLMs and AI Agents</span>"
    ]
  },
  {
    "objectID": "aifeature.html#lab-enhance-your-app-with-llm-powered-interpretation",
    "href": "aifeature.html#lab-enhance-your-app-with-llm-powered-interpretation",
    "title": "5¬† Build Applications with LLMs and AI Agents",
    "section": "5.2 Lab: Enhance Your App with LLM-Powered Interpretation",
    "text": "5.2 Lab: Enhance Your App with LLM-Powered Interpretation\nIn this lab, you will continue building your financial dashboard by integrating AI features with Google Gemini API.\n\n5.2.1 Get Started with Gemini API\nPlease sign in to Google AI Studio using your Google account https://ai.google.dev/aistudio.\n\n\n5.2.2 Create your Google Gemini API Key\nGoogle has a free tier for the Gemini API that provides limited usage for development and experimentation.\nYou can obtain a free API key using your Google account:\n\nhttps://aistudio.google.com/api-keys\n\n\nPlease delete your key if not in use. Keep it secure, and never share or publish your key.\n\n\n5.2.3 Run A Simple Gemini Use Case\nCheck out the page &lt;https://aistudio.google.com/app/&gt; for a simple use case of how to use Gemini API. You can easily create a Colab notebook and test the sample code there ‚Äî since both Gemini and Colab are Google products, they integrate seamlessly for quick experimentation.\nYou only need to modidy the following line with your api_key to run the sample code.\nclient = genai.Client(api_key=\"your_actual_api_key_here\")\n\nI successfully tested the Gemini Use Case.\n\n\n\n5.2.4 Prompt engineering\nA prompt is the input text or query given to a generative AI model to instruct it on what to do.\n\ne.g., ‚ÄúWrite a Python function to calculate the average of a list.‚Äù\n\nIn simple terms, prompt engineering is about communicating effectively with AI. It‚Äôs the skill of writing prompts so the large language models (LLMs) understands your intent, context, and background, and can respond accurately and usefully.\nIn other words:\n\nPrompt engineering = communication skills with LLMs.\n\n\n\n\n\n\n\nNote\n\n\n\nYou can explore prompt ideas for the Gemini API in Google AI studio. https://ai.google.dev/gemini-api/prompts\n\n\n\n\n5.2.5 Bad vs Good Prompts\nHere is a number of examples showing how vague prompts differs from well-engineered ones. AI can understand and act only as well as you communicate.\n\n\n\n\n\n\n\n\n\nTask\nBad Prompt\nGood Prompt\nWhy It‚Äôs Better\n\n\n\n\nAsk for code\n‚ÄúWrite some Python code for data.‚Äù\n‚ÄúWrite a Python function using pandas to read a CSV file, clean missing values, and calculate the average of each column.‚Äù\nGives clear context, specific goal, and tools to use.\n\n\nExplain concept\n‚ÄúExplain machine learning.‚Äù\n‚ÄúExplain what machine learning is for a high school student using everyday examples.‚Äù\nSpecifies audience and tone, making the response more focused.\n\n\nGenerate text\n‚ÄúWrite about climate change.‚Äù\n‚ÄúWrite a 3-paragraph summary of climate change causes and impacts, suitable for a classroom presentation.‚Äù\nDefines length, scope, and audience.\n\n\nData science task\n‚ÄúAnalyze this dataset.‚Äù\n‚ÄúAnalyze this dataset to find the top 5 products by sales, and visualize the trend over time using matplotlib.‚Äù\nSpecifies the goal, method, and output format.\n\n\n\nFunction to Get AI Interpretation of the Z-Score\n\n\n5.2.6 Task: Design a Value-Adding AI Prompt for Your Dashboard\nYour financial metrics dashboard already allows users to select tickers and view several metrics. Now, your goal is to design a prompt that integrates a LLM from Gemini to provide AI-generated insights that add value for the users of the dashboard.\n\nDesign your prompt with clear intent and context.\n\nThe prompt should generate something useful for the dashboard user.\nIntegrate your prompt into your streamlit app. You can build on the simple use case you successfully tested earlier and try integrating it into your streamlit app using Copilot.\nTest your prompt in the dashboard to ensure it gives clear, relevant, and user-friendly outputs.\nDocument why your prompt adds value and how it helps users make better sense of the data.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Build Applications with LLMs and AI Agents</span>"
    ]
  },
  {
    "objectID": "aifeature.html#lab-2-add-ai-agents-to-your-dashboard-optional",
    "href": "aifeature.html#lab-2-add-ai-agents-to-your-dashboard-optional",
    "title": "5¬† Build Applications with LLMs and AI Agents",
    "section": "5.3 Lab 2: Add AI Agents to your Dashboard (optional)",
    "text": "5.3 Lab 2: Add AI Agents to your Dashboard (optional)\nTo be released.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Build Applications with LLMs and AI Agents</span>"
    ]
  },
  {
    "objectID": "metrics.html",
    "href": "metrics.html",
    "title": "6¬† Lab - Business Metrics Dashboard",
    "section": "",
    "text": "Day 2",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Lab - Business Metrics Dashboard</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "1. Basic Command Line Crash Course",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "references.html#basic-command-line-crash-course",
    "href": "references.html#basic-command-line-crash-course",
    "title": "References",
    "section": "",
    "text": "Command Line Crash Course - Learn Python the Hard Way, Appendix A",
    "crumbs": [
      "References"
    ]
  }
]